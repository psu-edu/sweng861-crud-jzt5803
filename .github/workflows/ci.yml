# CI – Build, Test, Package
#
# This workflow runs on every push and pull request targeting the main branch.
# It performs three key stages:
#   1. build-and-test: Installs dependencies, builds the Next.js app, runs Jest
#      unit/frontend tests with coverage reporting, and audits for vulnerabilities.
#   2. docker-build: Builds a production Docker image using the project Dockerfile,
#      then smoke-tests the running container against the /api/health endpoint.
#
# Secrets used (fall back to safe CI defaults if not configured in repo settings):
#   - JWT_SECRET: used to sign JWT tokens
#   - NEXTAUTH_SECRET: used by NextAuth for session encryption

name: CI – Build, Test, Package

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  NODE_ENV: test

jobs:
  # ---------------------------------------------------------------------------
  # Job 1: Install, build, test, and audit
  # ---------------------------------------------------------------------------
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      # 1. Check out the repository at the triggering ref
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Set up Node.js 18 with npm caching for faster installs
      - name: Set up Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      # 3. Install all dependencies from the lockfile (clean, reproducible)
      - name: Install dependencies
        run: npm ci

      # 4. Build the Next.js application
      #    JWT_SECRET and NEXTAUTH_SECRET fall back to safe placeholder values
      #    when the corresponding repository secrets are not configured.
      - name: Build application
        run: npm run build
        env:
          NODE_ENV: test
          JWT_SECRET: ${{ secrets.JWT_SECRET || 'ci_jwt_secret_minimum_32_characters_long_for_testing' }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET || 'ci_nextauth_secret_minimum_32_chars_long' }}

      # 5. Run Jest unit and frontend tests with coverage.
      #    This step WILL fail the pipeline if any test fails (no continue-on-error).
      - name: Run Jest tests with coverage
        run: npm run test:coverage
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET || 'ci_jwt_secret_minimum_32_characters_long_for_testing' }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET || 'ci_nextauth_secret_minimum_32_chars_long' }}

      # 6. Upload the generated coverage report as a workflow artifact
      #    so it can be downloaded and reviewed after the run completes.
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/
          retention-days: 14

      # 7. Run npm security audit at the "high" severity level.
      #    Findings are surfaced as workflow warnings but do NOT fail the pipeline,
      #    because vulnerability state changes independently of the codebase.
      - name: Security audit
        run: npm audit --audit-level=high || echo "::warning::Security audit found high/critical vulnerabilities"
        continue-on-error: true

  # ---------------------------------------------------------------------------
  # Job 2: Build and smoke-test the Docker image
  # ---------------------------------------------------------------------------
  docker-build:
    needs: build-and-test
    runs-on: ubuntu-latest

    steps:
      # 1. Check out the repository so Docker can access the Dockerfile
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Set up Docker Buildx for advanced build capabilities
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3. Build the production Docker image and tag it with both the
      #    commit SHA (immutable, traceable) and "week6" (human-friendly label).
      - name: Build Docker image
        run: |
          docker build \
            -t campus-analytics:${{ github.sha }} \
            -t campus-analytics:week6 \
            .

      # 4. Smoke test: start the container, wait for it to initialize,
      #    verify the /api/health endpoint responds successfully, then clean up.
      - name: Smoke test – run container and check health endpoint
        run: |
          docker run -d --name test-app -p 3000:3000 \
            -e NODE_ENV=production \
            -e JWT_SECRET=ci_test_jwt_secret_minimum_32_characters_long \
            -e NEXTAUTH_SECRET=ci_test_nextauth_secret_minimum_32_chars \
            campus-analytics:week6
          sleep 15
          docker logs test-app
          curl --retry 5 --retry-delay 3 --retry-connrefused http://localhost:3000/api/health
          docker stop test-app && docker rm test-app
